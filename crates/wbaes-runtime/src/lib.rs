//! Runtime evaluation of white-box AES instances.
//!
//! Executes the table network generated by `wbaes-gen`, applying external
//! encodings and per-round tables to encrypt 32-byte blocks (two AES-128
//! blocks in parallel). This is research/educational code: no side-channel
//! hardening is provided, and external encodings are optional for testability.

#![forbid(unsafe_code)]
#![deny(missing_docs)]

use wbaes_gen::{ExternalEncodings, RoundTables, WbInstance256};

/// White-box AES-256-bit cipher (two AES-128 blocks).
pub struct WbCipher256 {
    instance: WbInstance256,
}

impl WbCipher256 {
    /// Creates a new runtime cipher from a generated instance.
    pub fn new(instance: WbInstance256) -> Self {
        Self { instance }
    }

    /// Encrypts a 32-byte block in place.
    pub fn encrypt_block(&self, block: &mut [u8; 32]) {
        apply_input_encoding(&self.instance.encodings, block);
        for round in &self.instance.rounds {
            apply_round(round, block);
        }
        if let Some(output_enc) = &self.instance.encodings.output {
            output_enc.apply_in_place(block);
        }
    }

    /// Encrypts two 16-byte blocks in place.
    pub fn encrypt_pair(&self, b1: &mut [u8; 16], b2: &mut [u8; 16]) {
        let mut block = [0u8; 32];
        block[..16].copy_from_slice(b1);
        block[16..].copy_from_slice(b2);
        self.encrypt_block(&mut block);
        b1.copy_from_slice(&block[..16]);
        b2.copy_from_slice(&block[16..]);
    }

    /// Borrows the underlying instance (useful for metadata or serialization).
    pub fn instance(&self) -> &WbInstance256 {
        &self.instance
    }
}

fn apply_input_encoding(encodings: &ExternalEncodings, state: &mut [u8; 32]) {
    encodings.input.apply_in_place(state);
}

fn apply_round(round: &RoundTables, state: &mut [u8; 32]) {
    let mut acc = [0u8; 32];
    for (i, table) in round.tables.iter().enumerate() {
        let x = state[i];
        let y = state[(i + 1) % 32];
        let entry = table.get(x, y);
        for (dst, src) in acc.iter_mut().zip(entry.iter()) {
            *dst ^= *src;
        }
    }
    *state = acc;
}

#[cfg(test)]
mod tests {
    use super::*;
    use aes_core::{encrypt_block, expand_key, Aes128Key};
    use rand::RngCore;
    use rand::SeedableRng;
    use rand_chacha::ChaCha20Rng;
    use wbaes_gen::{Generator, GeneratorConfig};

    #[test]
    fn runtime_matches_aes_for_random_inputs() {
        let mut rng = ChaCha20Rng::from_seed([42u8; 32]);
        let mut key_bytes = [0u8; 16];
        rng.fill_bytes(&mut key_bytes);
        let key = Aes128Key::from(key_bytes);

        let mut gen = Generator::with_config(
            ChaCha20Rng::from_seed([7u8; 32]),
            GeneratorConfig {
                external_encodings: false,
            },
        );
        let instance = gen.generate_instance(&key);
        let cipher = WbCipher256::new(instance);

        let round_keys = expand_key(&key);
        for _ in 0..3 {
            let mut block1 = [0u8; 16];
            let mut block2 = [0u8; 16];
            rng.fill_bytes(&mut block1);
            rng.fill_bytes(&mut block2);

            let mut block = [0u8; 32];
            block[..16].copy_from_slice(&block1);
            block[16..].copy_from_slice(&block2);

            cipher.encrypt_block(&mut block);

            let expected1 = encrypt_block(&block1, &round_keys);
            let expected2 = encrypt_block(&block2, &round_keys);

            assert_eq!(&block[..16], &expected1);
            assert_eq!(&block[16..], &expected2);
        }
    }

    #[test]
    fn encrypt_pair_matches_encrypt_block() {
        let mut rng = ChaCha20Rng::from_seed([9u8; 32]);
        let key = Aes128Key::from([0u8; 16]);
        let mut gen = Generator::new(ChaCha20Rng::from_seed([1u8; 32]));
        let instance = gen.generate_instance(&key);
        let cipher = WbCipher256::new(instance);

        let mut block1 = [0u8; 16];
        let mut block2 = [0u8; 16];
        rng.fill_bytes(&mut block1);
        rng.fill_bytes(&mut block2);

        let mut combined = [0u8; 32];
        combined[..16].copy_from_slice(&block1);
        combined[16..].copy_from_slice(&block2);
        cipher.encrypt_block(&mut combined);

        cipher.encrypt_pair(&mut block1, &mut block2);

        assert_eq!(&combined[..16], &block1);
        assert_eq!(&combined[16..], &block2);
    }
}
